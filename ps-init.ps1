
<#PSScriptInfo

.VERSION 0.4.4

.GUID 18038e71-ec43-4ebc-9155-8088908216f1

.AUTHOR Malnes

.COMPANYNAME SomeComp

.COPYRIGHT All rights reserved SomeComp

.TAGS

.LICENSEURI

.PROJECTURI

.ICONURI

.EXTERNALMODULEDEPENDENCIES 

.REQUIREDSCRIPTS

.EXTERNALSCRIPTDEPENDENCIES

.RELEASENOTES


.PRIVATEDATA

#>

<# 

.DESCRIPTION 
 Small script that creates a PowerShell project 
 

#> 

param (
    [Parameter()]
    [bool]$forceReprocess = $true
)
function new-ItemWithContent {
    param(
        [Parameter(Mandatory=$true)][string]$Path,
        [Parameter(Mandatory=$true)][string]$ItemType,
        [string]$Content
    )

    if (-not (Test-Path $Path)) {
        Write-Host "Creating $Path as it's missing" -ForegroundColor Green
        $item = New-Item -Path $Path -ItemType $ItemType -Force | Out-Null

        if ($ItemType -eq "File" -and $Content) {
            Add-Content -Path $Path -Value $Content
        }
    }
}

# Check if powershell 7 is installed
try {
    $pwshPath = (Get-Command pwsh).Source
    if (-not $pwshPath) {
        Write-Host "PowerShell 7 is not installed"
        Write-Host "Install PowerShell 7 and execute ps-init again"
        BREAK
    }
} catch {
    Write-Host "An error occurred. PowerShell 7 may not be installed."
    BREAK
}




# CREATE local.settings.json
$content = @{upn = "example@upn.com"; password = "Password"} | ConvertTo-Json
new-ItemWithContent -Path ".\local.settings.json" -ItemType "File" -Content $content

# CREATE project.settings.json
$content = @{url = "example.com"; guid = "0000000-0000-00000-00000000"} | ConvertTo-Json
new-ItemWithContent -Path ".\project.settings.json" -ItemType "File" -Content $content
    
# CREATE gitignore 
new-ItemWithContent -Path ".\.gitignore" -ItemType "File" -Content "modules`nlocal.settings.json"

# CREATE begin
$content = @"
# Code executed once at startup
# Write your startup code below

"@
new-ItemWithContent -Path ".\app\begin.ps1" -ItemType "File" -Content $content

# CREATE end
$content = @"
# Code executed once at completion
# Write your completion code below

"@
new-ItemWithContent -Path ".\app\end.ps1" -ItemType "File" -Content $content

# CREATE sequence
$content = @'
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE
# DO NOT EDIT THIS FILE

$psInitTargetVersion = "0.4.4"

# process module dependencies. Run with -forceReprocess if necessary
write-host "`nVerifying PS-init is installed with correct version" -f cyan
$psInitInstalled = Get-InstalledScript -Name "ps-init" -RequiredVersion $psInitTargetVersion -ErrorAction SilentlyContinue

if(-not $psInitInstalled) {
    Write-host "Installing PS-INIT"  -f cyan
    Install-Script -Name ps-init -RequiredVersion $psInitTargetVersion -Force
}

$psInitInstalled = Get-InstalledScript -Name "ps-init" -RequiredVersion $psInitTargetVersion -ErrorAction SilentlyContinue
write-host "PS-init version: $psInitInstalled"

ps-init -forceReprocess:$false
$LS = Get-Content .\local.settings.json | ConvertFrom-Json -Depth 10 -AsHashtable
$PS = Get-Content .\project.settings.json | ConvertFrom-Json -Depth 10 -AsHashtable
$var = $LS + $PS


# Execute the Initialization Script
Write-Host "`nStarting Initialization..."  -f cyan
. .\app\begin.ps1
Write-Host "`nInitialization Complete."  -f cyan

# Execute the Main Processing Loop Continuously
Write-Host "`nStarting Main Processing Loop..."  -f cyan
$continueLoop = $true
while ($continueLoop) {
    . .\app\main.ps1

    if ($finished -eq $true) {
        $continueLoop = $false
    } else {
        write-host "`nSelect option" -f green
        write-host "-------------" -f green
        write-host "[1] - Continue loop" -f green
        write-host "[2] - Exit loop" -f green
        $kljash = Read-Host ".."
        if ($kljash -ne 1) {
            $continueLoop = $false
        }
    }
}
Write-Host "`nMain Processing Loop Complete."  -f cyan

# Execute the Completion Script
Write-Host "`nStarting Completion Script..."  -f cyan
. .\app\end.ps1
Write-Host "`nCompletion Script Finished."  -f cyan
'@
new-ItemWithContent -Path ".\sequence.ps1" -ItemType "File" -Content $content

# CREATE app/main
$content = @"
<#
Main loop
- To end the loop or only run once, set the variable `$finished to `$true
- project settings and local settings can be accessed by using dot-notation on the variable `$var
- Execute script with the RUN.bat file

  Write your code below
#>


"@
new-ItemWithContent -Path ".\app" -ItemType "Directory"
new-ItemWithContent -Path ".\app\main.ps1" -ItemType "File" -Content $content


# CREATE RUN.bat
$content = @"
@echo off
cd %~dp0
"$pwshPath" -NoExit -ExecutionPolicy Bypass -File ".\sequence.ps1"

"@
new-ItemWithContent -Path ".\RUN.bat" -ItemType "File" -Content $content


# CREATE RUN-elevated.bat
$content = @"
@echo off
:: Check for administrative privileges
net session >nul 2>&1
if %errorlevel% == 0 (
    echo Running with administrative privileges
) else (
    echo Requesting administrative privileges...
    goto UACPrompt
)

:: Your original script here
cd %~dp0
"$pwshPath" -NoExit -ExecutionPolicy Bypass -File ".\sequence.ps1"
exit /b

:UACPrompt
echo Set UAC = CreateObject^("Shell.Application"^) > "%temp%\getadmin.vbs"
echo UAC.ShellExecute "%~s0", "", "", "runas", 1 >> "%temp%\getadmin.vbs"
"%temp%\getadmin.vbs"
exit /b
"@
new-ItemWithContent -Path ".\RUN-elevated.bat" -ItemType "File" -Content $content












# CREATE dependencies.psd1
$content = @"
@{
    # 'pnp.powershell' = '*'
    # 'microsoft.Graph.authentication' = '2.2.*'
    # 'microsoft.Graph.users' = '2.2.*'
}
"@
new-ItemWithContent -Path ".\dependencies.psd1" -ItemType "File" -Content $content

# CREATE modules
new-ItemWithContent -Path ".\modules" -ItemType "Directory"

# CREATE .vscode\launch.json
# $content = @"
# {
#     // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
#     "version": "0.2.0",
#     "configurations": [
#         {
#             "name": "PowerShell: Launch Script",
#             "type": "PowerShell",
#             "request": "launch",
#             "script": "${workspaceFolder}/app/main.ps1",
#             "args": []
#         }
#     ]
# }
# "@
# new-ItemWithContent -Path ".\.vscode" -ItemType "Directory"
# new-ItemWithContent -Path ".\.vscode\launch.json" -ItemType "File" -Content $content



# CREATE README.md
$content = @"
# PowerShell project

Version 0.4.0

## Requirements

- PowerShell 7

## How to use

Write your code in app\main.ps1. Any separate files should be created in the app folder.
Use RUN.bat to execute the script

## File overview

| File | Description |
|---|---|
| app\begin.ps1         | contains code that will be executen on start |
| app\main.ps1          | main loop and will be executed untill aborted |
| app\end.ps1           | contains code that will be executed once on completion |
| local.settings.json   | Local variable definition. Ignored by git |
| project.settings.json | Project variable definition. Igncluded in git |
| dependencies.osd1     | List of powershell modules and versions to be installed |


"@
new-ItemWithContent -Path ".\README.md" -ItemType "File" -Content $content




# Theck if dependencies has been modified and initialized
# Get current hash
$hash = get-filehash -Path .\dependencies.psd1 | select -ExpandProperty Hash

# Get saved hash (if any)
if(Test-Path .\modules\hash) {
    $savedHash = Get-Content .\modules\hash
    $savedHashAge = get-item .\modules\hash
    $now = get-date 
    $hashAge = $now - $savedHashAge.LastWriteTime | select -ExpandProperty days
} else {
    $hashAge = 999
}




# Process modules
# Start checking dependencies and stuff
Write-Host "`nChecking module dependencies..." -ForegroundColor Green
if($savedHash -ne $hash -or $hashAge -gt 7 -or $forceReprocess) {
    



    # Path to the Dependencies.psd1 file
    $dependenciesFilePath = '.\Dependencies.psd1'

    # Load dependencies from the .psd1 file
    $dependencies = Import-PowerShellDataFile -Path $dependenciesFilePath

    # Get the latest available module version according to the requirement in dependencies.psd1
    function Get-requiredModuleVersion {
        param (
            [string]$requiredVersion,
            [string]$moduleName
        )

        # Determine if requiredVersion has wildcards
        $hasWildcards = $requiredVersion -like "*[*?]*"

        # Get all available versions of the module
        $availableVersions = Find-Module -Name $moduleName -AllVersions | Select-Object -ExpandProperty Version


        # Filter and sort available versions based on the requiredVersion
        $filteredVersions = $availableVersions | Where-Object {
            if ($hasWildcards) {
                $pattern = New-Object System.Management.Automation.WildcardPattern($requiredVersion, [System.Management.Automation.WildcardOptions]::IgnoreCase)
                $pattern.IsMatch($_.ToString())
            } else {
                $_ -ge [Version]$requiredVersion
            }
        } | Sort-Object {[Version]$_} -Descending

        # Determine the latest available version that matches the requirement
        if([System.Management.Automation.WildcardPattern]::ContainsWildcardCharacters($requiredVersion)) {
            $latestAvailableVersion = $filteredVersions | Select-Object -First 1
        } else {
            $latestAvailableVersion = $filteredVersions | where {$_ -eq $requiredVersion}            
        }
    
        return $latestAvailableVersion
    }

    function Sort-PartsByDependencies {
        param (
            [Parameter(Mandatory=$true)]
            [array]$parts
        )
    
        # Convert JSON parts to a hashtable for easier access
        $dependencyGraph = @{}
        foreach ($part in $parts) {
            $dependencyGraph[$part.part] = $part.dependsOn
        }
    
        # Hashtable to keep track of whether a part is visited
        $visited = @{}
    
        # List to store the sorted parts
        $sortedParts = New-Object System.Collections.Generic.List[Object]
    
        # Recursive function to apply topological sorting
        function TopologicalSort($currentPart) {
            if ($visited[$currentPart] -eq $true) {
                return
            }
    
            if ($visited[$currentPart] -eq 'temp') {
                throw "Circular dependency detected."
            }
    
            # Mark this part as temporarily visited
            $visited[$currentPart] = 'temp'
    
            # Recursively visit all the dependencies first
            foreach ($dependency in $dependencyGraph[$currentPart]) {
                TopologicalSort $dependency
            }
    
            # Mark as permanently visited and add to sorted list
            $visited[$currentPart] = $true
            $sortedParts.Add($currentPart)
        }
    
        # Apply topological sort to each part
        foreach ($part in $dependencyGraph.Keys) {
            if (-not $visited.ContainsKey($part)) {
                TopologicalSort $part
            }
        }
    
        # Return the sorted list of parts
        return $sortedParts
    }
    


    # Downlaod modules
    foreach ($name in $dependencies.keys) {
        try {
            # Get our target version
            $targetVersion = $null
            [version]$targetVersion = Get-requiredModuleVersion -moduleName $name -requiredVersion $dependencies[$name]

            if (-not $targetVersion) {
                write-host "`nWARNING: Could not find module version $($dependencies[$name]) for the module $name" -f Yellow
            }

            # Check if module is installed
            if(test-path .\modules\$name) {

                #Check which version is installed
                [version]$installedVersion = Get-ChildItem .\modules\$name | select -ExpandProperty Name

                # Check if installed version is not the same as required version
                if ($targetVersion -ne $installedVersion) {

                    #Remove old and download new
                    write-host "Removing module with unwanted verison: `"$name`" Version `"$installedVersion`"" -f Yellow
                    remove-item -Path .\modules\$name -Recurse -Force | out-null

                    write-host "- Installing target version of module: `"$name`" Version `"$targetVersion`"" -f Green

                    Save-Module `
                        -Name $name `
                        -RequiredVersion $targetVersion `
                        -Path .\modules
                } else {
                    write-host "- Target module already installed: `"$name`" Version `"$installedVersion`"" -f Green

                }

            } else {
                # No module exist. Install it
                write-host "- Installing target version of module: `"$name`" Version `"$targetVersion`"" -f Green
                Save-Module `
                    -Name $name `
                    -RequiredVersion $targetVersion `
                    -Path .\modules
            }
        } catch {
            $_
            read-host "Press ENTER to continue..."
        }
    }

    # Remove unwanted modules
    [array]$installedModules   = Get-ChildItem -Path .\modules | where {$_.name -ne "hash"}
    [array]$requiredModules    = $dependencies.keys

    if($null -ne $requiredModules -and $null -ne $installedModules) {
        # Do a normal check
        $unusedModules = Compare-Object -ReferenceObject $installedModules.Name -DifferenceObject $requiredModules

    } elseif( $null -eq $requiredModules -and $null -ne $installedModules) {
        # No modules are required, but some modules are installed.
        $unusedModules = $installedModules

    } else {
        #do nothing
    }

    foreach ($unusedModule in $unusedModules) {
        write-host "- Removing unused module:`"$($unusedModule.inputObject)`"" -f Green
        remove-item -Path .\modules\$($unusedModule.inputObject) -Recurse -Force | out-null
    }
    write-host "`nDependencies complete!" -f Green


    # Sort modules for import after dependencies
    [array]$installedModules   = Get-ChildItem -Path .\modules | where {$_.name -ne "hash"}
    $moduleArr = @()
    foreach ($mod in $installedModules) {
        $obj = [PSCustomObject]@{
            part = $mod.name
            dependsOn = (get-module -name ".\modules\$($mod.name)" -ListAvailable).requiredModules | select -ExpandProperty name
        }
        $moduleArr += $obj
    }
    
    if($moduleArr) {
        $orderedImportList = Sort-PartsByDependencies -parts $moduleArr

        # Check for missing dependencies
        $missingModules = Compare-Object -ReferenceObject $orderedImportList -DifferenceObject $installedModules.name 
        if($missingModules) {
            write-host "ERROR: Missing dependencies:" -F Red

            foreach ($missingModule in $missingModules) {
                write-host "ERROR: - $($missingModules.inputObject)" -F Red
            }

            write-host "`nERROR: Add the missing module(s) to `"dependencies.psd1`" and try again"-F Red
            BREAK
        }
    }

    $newHash = get-filehash -Path .\dependencies.psd1 | select -ExpandProperty Hash
    $newHash | Out-File -FilePath .\modules\hash
    Write-Host "`nModules imported!`n" -f Green


} else {
    # Dependencies has not changed.
    write-host "No changes to me made" -f Green
 
}

# Final check to see if all modules are loaded
[array]$installedModules   = Get-ChildItem -Path .\modules | where {$_.name -ne "hash"}

# Import modules
Write-Host "`nImporting modules..." -f Green
foreach ($installedModule in $installedModules) {
    write-host "- Importing: $($installedModule.name)" -f Green
    # Check if- and remove previous imported module of same name
    if(get-module $($installedModule.name)) {
        try {
            Remove-Module $($installedModule.name) -force -ErrorAction Stop
        } catch {
            Write-Host "WARNING: Unable to reload `"$($installedModule.name)`". If this causes any issues, try running the script in a new terminal." -f Yellow
        }
    }

    #import module
    try {
        import-module .\modules\$($installedModule.name)
    } catch {
        if ($_.Exception.Message -eq "Assembly with same name is already loaded") {
            $assemblyLocation = [System.AppDomain]::CurrentDomain.GetAssemblies() | Where-Object Location | Sort-Object -Property FullName | Select-Object -Property FullName, Location, GlobalAssemblyCache, IsFullyTrusted | where {$_.FullName -match "$($installedModule.name)"} | select -ExpandProperty Location

            write-host "`nWarning: Assembly already loaded for $($installedModule.name). You are getting this error because importing modules also imports .NET assemblies, and while we can unload powershell modules, we cannot unload assemblies" -f Yellow
            write-host "This script installs and loads dependent modules in the project itself, but your current terminal have allready loaded another installed version ot the assembly from $assemblyLocation" -f Yellow
            write-host "You have three options:" -f Yellow
            write-host "1 - contune running the script. You will probably get a lot of error messages. Things might work, or it might not..." -f Yellow
            write-host "2 - Create and execute the code in a new terminal" -f Yellow
            write-host "3 - Close the folder, then restart vscode and try again" -f Yellow
            write-host "`nPress ENTER to continue, or press ctrl+c to abort (you should abort and go for step 2 or 3)"
            read-host ".."
            


        }
    }
}








# Verify that modules are imported (and installed)

$loadedModules = get-module | select -ExpandProperty name
$unloadedModules = @()
foreach ($m in $installedModules.name) {
    if ($loadedModules -notcontains $m) {
        $unloadedModules += $m
    }
}

if ($unloadedModules) {
    write-host "ERROR: Some required module(s) could not be loaded" -f Red
    foreach ($unM in $unloadedModules) {
        write-host "ERROR: - $unM" -f Red
    }
    write-host "`nERROR: Try rerunning the script, manually loading the module(s) or executing in a new terminal" -f Red
    write-host "Completed with errors" -f Yellow
} else {
    write-host "`nComplete!" -ForegroundColor Green

}




